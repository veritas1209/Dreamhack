from Crypto.Util.number import inverse, long_to_bytes
import sys

# ==============================================================================
# [중요] 방금 문제(prob.py)를 실행해서 나온 값을 아래에 덮어씌워주세요!
# 매번 실행할 때마다 숫자가 바뀌므로, 예전 숫자로 돌리면 절대 답이 안 나옵니다.
# ==============================================================================
p = 102917468046616568070479080437602349605790044856847368227989900438678598347252242912474630778930183524103498634272903762436029311481137741713080659077027483465896792512517855786714336938418831349151567425537183094315541122606131460802382497841037179253750742567612375678233281962828108691356598122015035462931
q = 155409405226203238058015527018600466439894178201393804291867914008619674289107580497614221099756010997177702316412488380301911465872315087011512265127913696978059566003514595719636467623534496220114055190116473471302619324855013682151351145662146108598413909004492093001297173273875378143449965795752096407249
e = 257
C = 9616384404213524657863670808981125526907268432622976664325249394851244870192789713737122799469499856887739253362805246859649606786263701308805488844336941066141053596437114630658542913559798796936296332917154444568198618992503828589914317105542317632873299732945292007245940129956165369995868033142331830348424499649247621627957887323716236781832428323377989036111392368810898382355775057357502240259332598797482858241354811610086476550911065698726091155648159869780115791767209206584503973202288411298660473001567148602289414544500536763463431773097574512189310225492456529147806648758189442259263483402853811323777
# ==============================================================================

def solve_crt(r1, m1, r2, m2):
    M = m1 * m2
    x = (r1 * m2 * inverse(m2, m1) + r2 * m1 * inverse(m1, m2)) % M
    return x

# 읽을 수 있는 문자열인지 확인하는 함수
def is_printable(b_str):
    # ASCII 범위(32~126)에 속하는 문자가 80% 이상이어야 함
    count = 0
    for b in b_str:
        if 32 <= b <= 126:
            count += 1
    if len(b_str) == 0: return False
    return (count / len(b_str)) > 0.8

print("[*] Calculating solutions...")

# 1. Mod q (정상 RSA)
dq = inverse(e, q - 1)
mq = pow(C, dq, q)

# 2. Mod p (특수해)
k = (p - 1) // e
dp_prime = inverse(e, k)
mp_base = pow(C, dp_prime, p)

# 3. 단위근(Root of Unity) 구하기
w = 1
for g in range(2, 1000):
    candidate = pow(g, k, p)
    if candidate != 1:
        w = candidate
        break

print(f"[+] Root of unity found. Scanning 257 candidates...")
print("-" * 60)

current_mp = mp_base
found_count = 0

for i in range(e):
    # CRT 결합
    msg_int = solve_crt(current_mp, p, mq, q)
    msg_bytes = long_to_bytes(msg_int)
    
    # [필터링] "DH{"로 시작하거나, 대부분이 읽을 수 있는 문자인 경우만 출력
    if b'DH{' in msg_bytes or is_printable(msg_bytes):
        print(f"\n[FOUND!] Candidate #{i}")
        print(f"Hex: {msg_bytes.hex()}")
        try:
            print(f"Str: {msg_bytes.decode()}")
        except:
            print(f"Str: (Decode Error) {msg_bytes}")
        found_count += 1
    
    # 다음 해 계산
    current_mp = (current_mp * w) % p

print("-" * 60)
if found_count == 0:
    print("[-] No readable flag found. Please CHECK if P, Q, C values match the current challenge run.")
else:
    print(f"[+] Found {found_count} potential flags.")